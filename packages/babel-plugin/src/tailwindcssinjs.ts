import fs from "fs";
import corePlugins from "tailwindcss/lib/corePlugins";
import {
  createTwClassDictionary,
  TailwindConfig,
  tailwindData,
} from "@tailwindcssinjs/tailwindcss-data";
import {
  twClassesComposer,
  twClassesParser,
  twClassesSerializer,
  TwClasses,
} from "@tailwindcssinjs/class-composer";
import postcss from "postcss";
import isEqual from "lodash/isEqual";
let configCache: TailwindConfig;
let tailwind: any;

export function tailwindcssinjs(config: any, outputPath: string) {
  if (!configCache || !isEqual(configCache, config)) {
    if (configCache)
      console.log("@tailwindcssinjs/macro - tailwind config changed");
    configCache = config;
    const twCache = new Set<string>();
    const {
      resolvedConfig,
      generateTwClassSubstituteRoot,
      utilitiesRoot,
      componentsRoot,
      baseRoot,
      screens,
    } = tailwindData(configCache, corePlugins);

    const twClassDictionary = createTwClassDictionary(
      componentsRoot,
      utilitiesRoot
    );

    const twComposer = twClassesComposer(resolvedConfig.separator);
    const twParser = twClassesParser(resolvedConfig.separator);
    const twSerializer = twClassesSerializer(resolvedConfig.separator);

    function compare(
      [firstClass, firstVariants]: [string, string[]],
      [secondClass, secondVariants]: [string, string[]]
    ) {
      const firstIsScreen = screens.indexOf(firstVariants[0]);
      const secondIsScreen = screens.indexOf(secondVariants[0]);
      if (firstIsScreen !== -1 || secondIsScreen !== -1) {
        if (firstIsScreen < secondIsScreen) {
          return -1;
        }
        if (firstIsScreen > secondIsScreen) {
          return 1;
        }
        return 0;
      }

      if (firstClass < secondClass) {
        return -1;
      }

      if (firstClass > secondClass) {
        return 1;
      }
      return 0;
    }

    const base = baseRoot.clone();
    const commentNode = postcss.comment({
      text: "Generated by @tailwindcssinjs/babel-plugin",
    });
    base.walkAtRules("layer", (atRule) => atRule.replaceWith(atRule.nodes));
    base.prepend(commentNode);

    tailwind = {
      setClasses: (twClasses: TwClasses) => {
        const composedTwClasses = twComposer(twClasses);
        for (const composedTwClass of composedTwClasses) {
          twCache.add(composedTwClass);
        }
        return twSerializer(twClasses);
      },
      writeCSS: () => {
        const parsedTwClasses = twParser(Array.from(twCache)).sort(compare);
        if (parsedTwClasses.length) {
          const combinedRoot = base.clone();
          for (const parsedTwClass of parsedTwClasses) {
            const twRoot = generateTwClassSubstituteRoot(
              twClassDictionary,
              parsedTwClass
            );
            combinedRoot.append(twRoot);
          }

          fs.writeFile(outputPath, combinedRoot.toString(), {}, () => { });
        } else {
          // console.log("no classes");
        }
      },
    };
  }
  return tailwind;
}
